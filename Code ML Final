### Les fonctions que nous utiliserons : 
    
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error
import operator

lin = LinearRegression()

def conso_opti_moy_reg(reg):
    a=meteo[meteo['region']==reg]['Conso_opti_pred']
    moy_mod=a.mean()
    return moy_mod

def conso2020_moy_reg(reg):
    a=meteo[meteo['region']==reg]['Conso_2020_pred']
    moy_mod=a.mean()
    return moy_mod

def conso_lf_moy_reg(reg):
    a=meteo[meteo['region']==reg]['Conso_lf_pred']
    moy_mod=a.mean()
    return moy_mod

def plot_reg(reg):                          ####### Cette fonction permet de plot par région directement

    x=meteo[meteo['region']== reg]['day']
    y=meteo[meteo['region']==reg]['Conso_2020_pred']
    z=meteo[meteo['region']==reg]['Conso_lf_pred']
    w=meteo[meteo['region']==reg]['Conso_opti_pred']
    fig, ax = plt.subplots(figsize=(15, 15))
    plt.plot(lissage(x,y,3)[0],lissage(x,y,3)[1],color='r',label='Consommation 2020')
    plt.plot(lissage(x,z,3)[0],lissage(x,z,3)[1], color='g',label='Consommation sc laisser faire')
    plt.plot(lissage(x,w,3)[0],lissage(x,w,3)[1], color='m',label= 'Consommation sc optimal')
    plt.legend()
    plt.xticks(Tab_Date,Tab_Date2)
    plt.title('Consommation en élécricité et gaz par jour')
    plt.xlabel('Mois')
    plt.ylabel('Consommation en élécricité et gaz')
    plt.show()

def prediction(pred):
    predarray = np.array([[pred]])
    a=lin.predict(poly.fit_transform(predarray))
    return a[0][0]

def Choixdeg (x,y,degree):                          ####### Cette fonction renvoie la mesure d'erreur du modéle en fonction du degrés du polynome, ceci pour obtenir la meilleure régression polynomiale possible
    polynomial_features= PolynomialFeatures(degree=degree)
    x_poly = polynomial_features.fit_transform(x)
    model = LinearRegression()
    model.fit(x_poly, y)
    y_poly_pred = model.predict(x_poly)
    rmse = np.sqrt(mean_squared_error(y,y_poly_pred))
    r2 = r2_score(y,y_poly_pred)
    sort_axis = operator.itemgetter(0)
    sorted_zip = sorted(zip(x,y_poly_pred), key=sort_axis)
    x_p, y_poly_pred_P = zip(*sorted_zip)
    return rmse, x_p, y_poly_pred_P,r2

  
### On ajoute simplement quelque valeurs cohérente aux valeurs données pour mieux considérer le modéle lorsque la température moyenne est élevé
x=meteo_pic_conso['temperature_moyenne'].to_numpy()
x2=np.array([30,29,29,28,28,26,28,30,29])
x= np.append(x,x2)
x=x.reshape(-1,1)

y=meteo_pic_conso['pic_journalier_consommation'].to_numpy()
y2=np.array([57000,55700,57000,54500,55475,53800,53400,55000,55200])
y=np.append(y,y2)
y=y.reshape(-1,1)
    
## On détermine avec la fonction Choixdeg le meillleur degrés   
r2_list = np.zeros(50)
rmselist = np.zeros(50)
x_p_list = [None]*50
y_poly_pred_P_list=[None]*50

for i in np.arange(1, 51):
   rmselist[i-1] ,x_p_list[i-1],y_poly_pred_P_list[i-1],r2_list[i-1]= Choixdeg (x,y,i)



### On plot :
        
plt.plot(np.arange(1, 51), rmselist, color='r',label='MSE')
plt.xticks(np.arange(0, 50,2))
plt.title('Calcul du MSE selon le degrés du polynôme')
plt.show()

plt.plot(np.arange(1, 51), r2_list, color='g',label='R2')
plt.xticks(np.arange(0, 50,2))
plt.xlabel('Degrés')
plt.ylabel('R2')
plt.title(' R2 en fonction du degrés du polynôme')
plt.show()
    
Min=list(rmselist).index(min(rmselist))
Max=list(r2_list).index(max(r2_list))

 

#on transforme les variables X et Y de maniére a ce qu'elle soit lisible dans le programme suivant 
X= meteo_pic_conso['temperature_moyenne'].to_numpy().reshape(-1,1)
Y = meteo_pic_conso['pic_journalier_consommation'].to_numpy().reshape(-1,1)

  
#On découpe la base d'apprentissage et la base de test
  
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)    


def evalPolynonmialRegression(degree):
    #entrainement du modèle
    polynomial_features= PolynomialFeatures(degree=degree)
    X_train_poly = polynomial_features.fit_transform(X_train)
    X_test_poly = polynomial_features.fit_transform(X_test)
    model = LinearRegression()
    model.fit(X_train_poly, Y_train)
    # Evaluation du training set
 
    y_train_predict = model.predict(X_train_poly)
    rmse_train = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))
    r2_train = r2_score(Y_train, y_train_predict)
 
 
    # Evaluation du testing set
    y_test_predict = model.predict(X_test_poly)
    rmse_test = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
    r2_test = r2_score(Y_test, y_test_predict)
    
    return rmse_train ,rmse_test, r2_train,r2_test,y_train_predict,X_train_poly

#On choisit le degrés le plus convainquant parmis ceux minimisant le rse et maximisant le R2, en loccurence 4

poly=PolynomialFeatures(4)
Y_Train=evalPolynonmialRegression(4)[4]
X_Train=evalPolynonmialRegression(4)[5]

#Puis on plot

plt.plot(x_p_list[4],y_poly_pred_P_list[4],color='r',linewidth=3)
plt.scatter(x, y)
plt.title('Corrélation température consommation energie')
plt.xlabel('Température')
plt.ylabel('Consommation en énergie')

#On creer le modéle de prédiciton désormais

X_poly = poly.fit_transform(x)
poly.fit(X_Train, Y_Train)
lin.fit(X_Train, Y_Train)

##On test avec la fonction prediction

#### On applique la regression a nos données

meteo = meteo.dropna()
meteo = meteo.groupby(['region','day']).mean()
meteo = meteo.reset_index(level='region')
meteo = meteo.reset_index(level='day')
meteo['Conso_opti_pred']= meteo['Temp_opti'].apply(prediction)
meteo['Conso_lf_pred']= meteo['Temp_lf'].apply(prediction)
meteo['Conso_2020_pred']= meteo['TempMoy_Deg'].apply(prediction)

##### On peut plot n'importe quelle région, et analyser les conséquence en générale.
plot_reg('Hauts-de-France')  ##### On analyse une baisse de conso en été pour les scenario 2050, et un niveau stable en hiver
plot_reg('Provence-Alpes-Cote-d Azur') #### Plus de consommation en été en 2050, toujours moins en Hiver




# UNE DATAVIZ POUR NABIZ



Tab_conso_moy = pd.DataFrame(columns=['Conso_2020','Conso Opti','Conso Lf'],index=Regions)
Tab_conso_moy= Tab_conso_moy.reset_index()
Tab_conso_moy['Pic_Conso_opti(MW)/Jour']=Tab_conso_moy['index'].apply(conso_opti_moy_reg)
Tab_conso_moy['Pic_Conso_2020/Jour']=Tab_conso_moy['index'].apply(conso2020_moy_reg)
Tab_conso_moy['Pic_Conso_lf(MW)/Jour']=Tab_conso_moy['index'].apply(conso_lf_moy_reg)
Tab_conso_moy['Evolution 2020 / Opti']=(1-Tab_conso_moy['Pic_Conso_2020/Jour']/Tab_conso_moy['Pic_Conso_lf(MW)/Jour'])*100



# A travers ce dataframe, on peut etudier les variations de consommation d'energie selon les différents scnéario. Je pense qu'il peut etre interessant de plot une carte de la france avec les régions, et les colorier en fonction de l'évolution de la consommation ( bleu si ca bouge pas trop, rouge sinon) 

