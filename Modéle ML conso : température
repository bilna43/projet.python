import pandas as pd
import numpy as np
import operator
from sklearn.metrics import mean_squared_error

import matplotlib.pyplot as plt
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score





meteo=pd.read_excel("/Users/tiber/Documents/Projet Python/pic-journalier-consommation-brute.xlsx")
prevision= pd.read_excel("/Users/tiber/Documents/Projet Python/Données de l'AFP prévision.xlsx")

plt.plot(meteo['temperature_moyenne'],meteo['pic_journalier_consommation'])
plt.title('Consommation energetique en fonction de la température')
plt.xlabel('Température')
plt.ylabel('Consommation en énergie')
plt.show()

x=meteo['temperature_moyenne'].to_numpy()
x2=np.array([30,29,29,28,28,26,28,30,29])
x= np.append(x,x2)
x=x.reshape(-1,1)

y=meteo['pic_journalier_consommation'].to_numpy()
y2=np.array([57000,55700,57000,54500,55475,53800,53400,55000,55200])
y=np.append(y,y2)
y=y.reshape(-1,1)

lin = LinearRegression()


def Choixdeg (x,y,degree):
    polynomial_features= PolynomialFeatures(degree=degree)
    x_poly = polynomial_features.fit_transform(x)
    model = LinearRegression()
    model.fit(x_poly, y)
    y_poly_pred = model.predict(x_poly)
    rmse = np.sqrt(mean_squared_error(y,y_poly_pred))
    sort_axis = operator.itemgetter(0)
    sorted_zip = sorted(zip(x,y_poly_pred), key=sort_axis)
    x_p, y_poly_pred_P = zip(*sorted_zip)
    return rmse, x_p, y_poly_pred_P
 
rmselist = np.zeros(50)
x_p_list = [None]*50
y_poly_pred_P_list=[None]*50

for i in np.arange(1, 51):
     
    rmselist[i-1] ,x_p_list[i-1],y_poly_pred_P_list[i-1]= Choixdeg (x,y,i)
     
plt.plot(np.arange(1, 51), rmselist, color='r')
plt.xticks(np.arange(0, 50,2))
plt.title('Calcul du MSE selon le degrés du polynôme')
plt.show()

# On trouve le degrés qui minimise l erreur mse : 

Min=list(rmselist).index(min(rmselist))

# Désormais on calcul et on trace la regression : 

 
#on utilise seulement 4 variables explicatives
X= meteo['temperature_moyenne'].to_numpy().reshape(-1,1)
Y = meteo['pic_journalier_consommation'].to_numpy().reshape(-1,1)
  
#base d'apprentissage et base de test
  
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)    

def evalPolynonmialRegression(degree):
    #entrainement du modèle
    polynomial_features= PolynomialFeatures(degree=degree)
    X_train_poly = polynomial_features.fit_transform(X_train)
    X_test_poly = polynomial_features.fit_transform(X_test)
    model = LinearRegression()
    model.fit(X_train_poly, Y_train)
    # Evaluation du training set
 
    y_train_predict = model.predict(X_train_poly)
    rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))
    r2 = r2_score(Y_train, y_train_predict)
 
 
    # Evaluation du testing set
    y_test_predict = model.predict(X_test_poly)
    rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
    r2 = r2_score(Y_test, y_test_predict)
    


    return model,r2 ,rmse


#En utilisatn les informations sur le minimum du MSE, et la courbe tracé, on en déduit que le degrés optimal est 6

poly=PolynomialFeatures(6)

plt.plot(x_p_list[6],y_poly_pred_P_list[6],color='r',linewidth=3)
plt.scatter(x, y)
plt.title('Corrélation température consommation energie')
plt.xlabel('Température')
plt.ylabel('Consommation en énergie')
